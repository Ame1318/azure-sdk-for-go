// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// WorkloadNetworksClient contains the methods for the WorkloadNetworks group.
// Don't use this type directly, use NewWorkloadNetworksClient() instead.
type WorkloadNetworksClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewWorkloadNetworksClient creates a new instance of WorkloadNetworksClient with the specified values.
func NewWorkloadNetworksClient(con *armcore.Connection, subscriptionID string) *WorkloadNetworksClient {
	return &WorkloadNetworksClient{con: con, subscriptionID: subscriptionID}
}

// BeginCreateDhcp - Create dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginCreateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (WorkloadNetworkDhcpPollerResponse, error) {
	resp, err := client.createDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return WorkloadNetworkDhcpPollerResponse{}, err
	}
	result := WorkloadNetworkDhcpPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.CreateDhcp", "", resp, client.createDhcpHandleError)
	if err != nil {
		return WorkloadNetworkDhcpPollerResponse{}, err
	}
	poller := &workloadNetworkDhcpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkDhcpResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateDhcp creates a new WorkloadNetworkDhcpPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkDhcpPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeCreateDhcp(token string) (WorkloadNetworkDhcpPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.CreateDhcp", token, client.createDhcpHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkDhcpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateDhcp - Create dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) createDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (*azcore.Response, error) {
	req, err := client.createDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createDhcpHandleError(resp)
	}
	return resp, nil
}

// createDhcpCreateRequest creates the CreateDhcp request.
func (client *WorkloadNetworksClient) createDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkDhcp)
}

// createDhcpHandleResponse handles the CreateDhcp response.
func (client *WorkloadNetworksClient) createDhcpHandleResponse(resp *azcore.Response) (WorkloadNetworkDhcpResponse, error) {
	var val *WorkloadNetworkDhcp
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkDhcpResponse{}, err
	}
	return WorkloadNetworkDhcpResponse{RawResponse: resp.Response, WorkloadNetworkDhcp: val}, nil
}

// createDhcpHandleError handles the CreateDhcp error response.
func (client *WorkloadNetworksClient) createDhcpHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginCreatePortMirroring - Create a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginCreatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (WorkloadNetworkPortMirroringPollerResponse, error) {
	resp, err := client.createPortMirroring(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return WorkloadNetworkPortMirroringPollerResponse{}, err
	}
	result := WorkloadNetworkPortMirroringPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.CreatePortMirroring", "", resp, client.createPortMirroringHandleError)
	if err != nil {
		return WorkloadNetworkPortMirroringPollerResponse{}, err
	}
	poller := &workloadNetworkPortMirroringPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkPortMirroringResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreatePortMirroring creates a new WorkloadNetworkPortMirroringPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkPortMirroringPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeCreatePortMirroring(token string) (WorkloadNetworkPortMirroringPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.CreatePortMirroring", token, client.createPortMirroringHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkPortMirroringPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreatePortMirroring - Create a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) createPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (*azcore.Response, error) {
	req, err := client.createPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createPortMirroringHandleError(resp)
	}
	return resp, nil
}

// createPortMirroringCreateRequest creates the CreatePortMirroring request.
func (client *WorkloadNetworksClient) createPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkPortMirroring)
}

// createPortMirroringHandleResponse handles the CreatePortMirroring response.
func (client *WorkloadNetworksClient) createPortMirroringHandleResponse(resp *azcore.Response) (WorkloadNetworkPortMirroringResponse, error) {
	var val *WorkloadNetworkPortMirroring
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkPortMirroringResponse{}, err
	}
	return WorkloadNetworkPortMirroringResponse{RawResponse: resp.Response, WorkloadNetworkPortMirroring: val}, nil
}

// createPortMirroringHandleError handles the CreatePortMirroring error response.
func (client *WorkloadNetworksClient) createPortMirroringHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginCreateSegments - Create a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginCreateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (WorkloadNetworkSegmentPollerResponse, error) {
	resp, err := client.createSegments(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return WorkloadNetworkSegmentPollerResponse{}, err
	}
	result := WorkloadNetworkSegmentPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.CreateSegments", "", resp, client.createSegmentsHandleError)
	if err != nil {
		return WorkloadNetworkSegmentPollerResponse{}, err
	}
	poller := &workloadNetworkSegmentPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkSegmentResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateSegments creates a new WorkloadNetworkSegmentPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkSegmentPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeCreateSegments(token string) (WorkloadNetworkSegmentPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.CreateSegments", token, client.createSegmentsHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkSegmentPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateSegments - Create a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) createSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (*azcore.Response, error) {
	req, err := client.createSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createSegmentsHandleError(resp)
	}
	return resp, nil
}

// createSegmentsCreateRequest creates the CreateSegments request.
func (client *WorkloadNetworksClient) createSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkSegment)
}

// createSegmentsHandleResponse handles the CreateSegments response.
func (client *WorkloadNetworksClient) createSegmentsHandleResponse(resp *azcore.Response) (WorkloadNetworkSegmentResponse, error) {
	var val *WorkloadNetworkSegment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkSegmentResponse{}, err
	}
	return WorkloadNetworkSegmentResponse{RawResponse: resp.Response, WorkloadNetworkSegment: val}, nil
}

// createSegmentsHandleError handles the CreateSegments error response.
func (client *WorkloadNetworksClient) createSegmentsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginCreateVMGroup - Create a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginCreateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (WorkloadNetworkVMGroupPollerResponse, error) {
	resp, err := client.createVMGroup(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return WorkloadNetworkVMGroupPollerResponse{}, err
	}
	result := WorkloadNetworkVMGroupPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.CreateVMGroup", "", resp, client.createVMGroupHandleError)
	if err != nil {
		return WorkloadNetworkVMGroupPollerResponse{}, err
	}
	poller := &workloadNetworkVMGroupPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkVMGroupResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateVMGroup creates a new WorkloadNetworkVMGroupPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkVMGroupPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeCreateVMGroup(token string) (WorkloadNetworkVMGroupPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.CreateVMGroup", token, client.createVMGroupHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkVMGroupPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateVMGroup - Create a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) createVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (*azcore.Response, error) {
	req, err := client.createVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createVMGroupHandleError(resp)
	}
	return resp, nil
}

// createVMGroupCreateRequest creates the CreateVMGroup request.
func (client *WorkloadNetworksClient) createVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkVMGroup)
}

// createVMGroupHandleResponse handles the CreateVMGroup response.
func (client *WorkloadNetworksClient) createVMGroupHandleResponse(resp *azcore.Response) (WorkloadNetworkVMGroupResponse, error) {
	var val *WorkloadNetworkVMGroup
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVMGroupResponse{}, err
	}
	return WorkloadNetworkVMGroupResponse{RawResponse: resp.Response, WorkloadNetworkVMGroup: val}, nil
}

// createVMGroupHandleError handles the CreateVMGroup error response.
func (client *WorkloadNetworksClient) createVMGroupHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginDeleteDhcp - Delete dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginDeleteDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.DeleteDhcp", "", resp, client.deleteDhcpHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteDhcp creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeDeleteDhcp(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteDhcp", token, client.deleteDhcpHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteDhcp - Delete dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) deleteDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (*azcore.Response, error) {
	req, err := client.deleteDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteDhcpHandleError(resp)
	}
	return resp, nil
}

// deleteDhcpCreateRequest creates the DeleteDhcp request.
func (client *WorkloadNetworksClient) deleteDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDhcpHandleError handles the DeleteDhcp error response.
func (client *WorkloadNetworksClient) deleteDhcpHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginDeletePortMirroring - Delete a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginDeletePortMirroring(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (HTTPPollerResponse, error) {
	resp, err := client.deletePortMirroring(ctx, resourceGroupName, portMirroringID, privateCloudName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.DeletePortMirroring", "", resp, client.deletePortMirroringHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeletePortMirroring creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeDeletePortMirroring(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.DeletePortMirroring", token, client.deletePortMirroringHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeletePortMirroring - Delete a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) deletePortMirroring(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (*azcore.Response, error) {
	req, err := client.deletePortMirroringCreateRequest(ctx, resourceGroupName, portMirroringID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePortMirroringHandleError(resp)
	}
	return resp, nil
}

// deletePortMirroringCreateRequest creates the DeletePortMirroring request.
func (client *WorkloadNetworksClient) deletePortMirroringCreateRequest(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePortMirroringHandleError handles the DeletePortMirroring error response.
func (client *WorkloadNetworksClient) deletePortMirroringHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginDeleteSegment - Delete a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginDeleteSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteSegment(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.DeleteSegment", "", resp, client.deleteSegmentHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteSegment creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeDeleteSegment(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteSegment", token, client.deleteSegmentHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteSegment - Delete a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) deleteSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (*azcore.Response, error) {
	req, err := client.deleteSegmentCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteSegmentHandleError(resp)
	}
	return resp, nil
}

// deleteSegmentCreateRequest creates the DeleteSegment request.
func (client *WorkloadNetworksClient) deleteSegmentCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSegmentHandleError handles the DeleteSegment error response.
func (client *WorkloadNetworksClient) deleteSegmentHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginDeleteVMGroup - Delete a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginDeleteVMGroup(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteVMGroup(ctx, resourceGroupName, vmGroupID, privateCloudName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.DeleteVMGroup", "", resp, client.deleteVMGroupHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteVMGroup creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeDeleteVMGroup(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteVMGroup", token, client.deleteVMGroupHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteVMGroup - Delete a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) deleteVMGroup(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (*azcore.Response, error) {
	req, err := client.deleteVMGroupCreateRequest(ctx, resourceGroupName, vmGroupID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteVMGroupHandleError(resp)
	}
	return resp, nil
}

// deleteVMGroupCreateRequest creates the DeleteVMGroup request.
func (client *WorkloadNetworksClient) deleteVMGroupCreateRequest(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVMGroupHandleError handles the DeleteVMGroup error response.
func (client *WorkloadNetworksClient) deleteVMGroupHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDhcp - Get dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetDhcp(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string, options *WorkloadNetworksGetDhcpOptions) (WorkloadNetworkDhcpResponse, error) {
	req, err := client.getDhcpCreateRequest(ctx, resourceGroupName, dhcpID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworkDhcpResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkDhcpResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkDhcpResponse{}, client.getDhcpHandleError(resp)
	}
	return client.getDhcpHandleResponse(resp)
}

// getDhcpCreateRequest creates the GetDhcp request.
func (client *WorkloadNetworksClient) getDhcpCreateRequest(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string, options *WorkloadNetworksGetDhcpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDhcpHandleResponse handles the GetDhcp response.
func (client *WorkloadNetworksClient) getDhcpHandleResponse(resp *azcore.Response) (WorkloadNetworkDhcpResponse, error) {
	var val *WorkloadNetworkDhcp
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkDhcpResponse{}, err
	}
	return WorkloadNetworkDhcpResponse{RawResponse: resp.Response, WorkloadNetworkDhcp: val}, nil
}

// getDhcpHandleError handles the GetDhcp error response.
func (client *WorkloadNetworksClient) getDhcpHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetGateway - Get a gateway by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetGateway(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string, options *WorkloadNetworksGetGatewayOptions) (WorkloadNetworkGatewayResponse, error) {
	req, err := client.getGatewayCreateRequest(ctx, resourceGroupName, privateCloudName, gatewayID, options)
	if err != nil {
		return WorkloadNetworkGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkGatewayResponse{}, client.getGatewayHandleError(resp)
	}
	return client.getGatewayHandleResponse(resp)
}

// getGatewayCreateRequest creates the GetGateway request.
func (client *WorkloadNetworksClient) getGatewayCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string, options *WorkloadNetworksGetGatewayOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if gatewayID == "" {
		return nil, errors.New("parameter gatewayID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayId}", url.PathEscape(gatewayID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGatewayHandleResponse handles the GetGateway response.
func (client *WorkloadNetworksClient) getGatewayHandleResponse(resp *azcore.Response) (WorkloadNetworkGatewayResponse, error) {
	var val *WorkloadNetworkGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkGatewayResponse{}, err
	}
	return WorkloadNetworkGatewayResponse{RawResponse: resp.Response, WorkloadNetworkGateway: val}, nil
}

// getGatewayHandleError handles the GetGateway error response.
func (client *WorkloadNetworksClient) getGatewayHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetPortMirroring - Get a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, options *WorkloadNetworksGetPortMirroringOptions) (WorkloadNetworkPortMirroringResponse, error) {
	req, err := client.getPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, options)
	if err != nil {
		return WorkloadNetworkPortMirroringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkPortMirroringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkPortMirroringResponse{}, client.getPortMirroringHandleError(resp)
	}
	return client.getPortMirroringHandleResponse(resp)
}

// getPortMirroringCreateRequest creates the GetPortMirroring request.
func (client *WorkloadNetworksClient) getPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, options *WorkloadNetworksGetPortMirroringOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPortMirroringHandleResponse handles the GetPortMirroring response.
func (client *WorkloadNetworksClient) getPortMirroringHandleResponse(resp *azcore.Response) (WorkloadNetworkPortMirroringResponse, error) {
	var val *WorkloadNetworkPortMirroring
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkPortMirroringResponse{}, err
	}
	return WorkloadNetworkPortMirroringResponse{RawResponse: resp.Response, WorkloadNetworkPortMirroring: val}, nil
}

// getPortMirroringHandleError handles the GetPortMirroring error response.
func (client *WorkloadNetworksClient) getPortMirroringHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetSegment - Get a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksGetSegmentOptions) (WorkloadNetworkSegmentResponse, error) {
	req, err := client.getSegmentCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return WorkloadNetworkSegmentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkSegmentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkSegmentResponse{}, client.getSegmentHandleError(resp)
	}
	return client.getSegmentHandleResponse(resp)
}

// getSegmentCreateRequest creates the GetSegment request.
func (client *WorkloadNetworksClient) getSegmentCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksGetSegmentOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSegmentHandleResponse handles the GetSegment response.
func (client *WorkloadNetworksClient) getSegmentHandleResponse(resp *azcore.Response) (WorkloadNetworkSegmentResponse, error) {
	var val *WorkloadNetworkSegment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkSegmentResponse{}, err
	}
	return WorkloadNetworkSegmentResponse{RawResponse: resp.Response, WorkloadNetworkSegment: val}, nil
}

// getSegmentHandleError handles the GetSegment error response.
func (client *WorkloadNetworksClient) getSegmentHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetVMGroup - Get a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, options *WorkloadNetworksGetVMGroupOptions) (WorkloadNetworkVMGroupResponse, error) {
	req, err := client.getVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, options)
	if err != nil {
		return WorkloadNetworkVMGroupResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkVMGroupResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkVMGroupResponse{}, client.getVMGroupHandleError(resp)
	}
	return client.getVMGroupHandleResponse(resp)
}

// getVMGroupCreateRequest creates the GetVMGroup request.
func (client *WorkloadNetworksClient) getVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, options *WorkloadNetworksGetVMGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVMGroupHandleResponse handles the GetVMGroup response.
func (client *WorkloadNetworksClient) getVMGroupHandleResponse(resp *azcore.Response) (WorkloadNetworkVMGroupResponse, error) {
	var val *WorkloadNetworkVMGroup
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVMGroupResponse{}, err
	}
	return WorkloadNetworkVMGroupResponse{RawResponse: resp.Response, WorkloadNetworkVMGroup: val}, nil
}

// getVMGroupHandleError handles the GetVMGroup error response.
func (client *WorkloadNetworksClient) getVMGroupHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetVirtualMachine - Get a virtual machine by id in a private cloud workload network.
func (client *WorkloadNetworksClient) GetVirtualMachine(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string, options *WorkloadNetworksGetVirtualMachineOptions) (WorkloadNetworkVirtualMachineResponse, error) {
	req, err := client.getVirtualMachineCreateRequest(ctx, resourceGroupName, privateCloudName, virtualMachineID, options)
	if err != nil {
		return WorkloadNetworkVirtualMachineResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WorkloadNetworkVirtualMachineResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WorkloadNetworkVirtualMachineResponse{}, client.getVirtualMachineHandleError(resp)
	}
	return client.getVirtualMachineHandleResponse(resp)
}

// getVirtualMachineCreateRequest creates the GetVirtualMachine request.
func (client *WorkloadNetworksClient) getVirtualMachineCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string, options *WorkloadNetworksGetVirtualMachineOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if virtualMachineID == "" {
		return nil, errors.New("parameter virtualMachineID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{virtualMachineId}", url.PathEscape(virtualMachineID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVirtualMachineHandleResponse handles the GetVirtualMachine response.
func (client *WorkloadNetworksClient) getVirtualMachineHandleResponse(resp *azcore.Response) (WorkloadNetworkVirtualMachineResponse, error) {
	var val *WorkloadNetworkVirtualMachine
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVirtualMachineResponse{}, err
	}
	return WorkloadNetworkVirtualMachineResponse{RawResponse: resp.Response, WorkloadNetworkVirtualMachine: val}, nil
}

// getVirtualMachineHandleError handles the GetVirtualMachine error response.
func (client *WorkloadNetworksClient) getVirtualMachineHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListDhcp - List dhcp in a private cloud workload network.
func (client *WorkloadNetworksClient) ListDhcp(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDhcpOptions) WorkloadNetworkDhcpListPager {
	return &workloadNetworkDhcpListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listDhcpHandleResponse,
		errorer:   client.listDhcpHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkDhcpListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkDhcpList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listDhcpCreateRequest creates the ListDhcp request.
func (client *WorkloadNetworksClient) listDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDhcpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDhcpHandleResponse handles the ListDhcp response.
func (client *WorkloadNetworksClient) listDhcpHandleResponse(resp *azcore.Response) (WorkloadNetworkDhcpListResponse, error) {
	var val *WorkloadNetworkDhcpList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkDhcpListResponse{}, err
	}
	return WorkloadNetworkDhcpListResponse{RawResponse: resp.Response, WorkloadNetworkDhcpList: val}, nil
}

// listDhcpHandleError handles the ListDhcp error response.
func (client *WorkloadNetworksClient) listDhcpHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListGateways - List of gateways in a private cloud workload network.
func (client *WorkloadNetworksClient) ListGateways(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListGatewaysOptions) WorkloadNetworkGatewayListPager {
	return &workloadNetworkGatewayListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listGatewaysCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listGatewaysHandleResponse,
		errorer:   client.listGatewaysHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkGatewayListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkGatewayList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listGatewaysCreateRequest creates the ListGateways request.
func (client *WorkloadNetworksClient) listGatewaysCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListGatewaysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listGatewaysHandleResponse handles the ListGateways response.
func (client *WorkloadNetworksClient) listGatewaysHandleResponse(resp *azcore.Response) (WorkloadNetworkGatewayListResponse, error) {
	var val *WorkloadNetworkGatewayList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkGatewayListResponse{}, err
	}
	return WorkloadNetworkGatewayListResponse{RawResponse: resp.Response, WorkloadNetworkGatewayList: val}, nil
}

// listGatewaysHandleError handles the ListGateways error response.
func (client *WorkloadNetworksClient) listGatewaysHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListPortMirroring - List of port mirroring profiles in a private cloud workload network.
func (client *WorkloadNetworksClient) ListPortMirroring(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPortMirroringOptions) WorkloadNetworkPortMirroringListPager {
	return &workloadNetworkPortMirroringListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listPortMirroringHandleResponse,
		errorer:   client.listPortMirroringHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkPortMirroringListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkPortMirroringList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPortMirroringCreateRequest creates the ListPortMirroring request.
func (client *WorkloadNetworksClient) listPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPortMirroringOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPortMirroringHandleResponse handles the ListPortMirroring response.
func (client *WorkloadNetworksClient) listPortMirroringHandleResponse(resp *azcore.Response) (WorkloadNetworkPortMirroringListResponse, error) {
	var val *WorkloadNetworkPortMirroringList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkPortMirroringListResponse{}, err
	}
	return WorkloadNetworkPortMirroringListResponse{RawResponse: resp.Response, WorkloadNetworkPortMirroringList: val}, nil
}

// listPortMirroringHandleError handles the ListPortMirroring error response.
func (client *WorkloadNetworksClient) listPortMirroringHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListSegments - List of segments in a private cloud workload network.
func (client *WorkloadNetworksClient) ListSegments(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListSegmentsOptions) WorkloadNetworkSegmentsListPager {
	return &workloadNetworkSegmentsListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listSegmentsHandleResponse,
		errorer:   client.listSegmentsHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkSegmentsListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkSegmentsList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSegmentsCreateRequest creates the ListSegments request.
func (client *WorkloadNetworksClient) listSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListSegmentsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSegmentsHandleResponse handles the ListSegments response.
func (client *WorkloadNetworksClient) listSegmentsHandleResponse(resp *azcore.Response) (WorkloadNetworkSegmentsListResponse, error) {
	var val *WorkloadNetworkSegmentsList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkSegmentsListResponse{}, err
	}
	return WorkloadNetworkSegmentsListResponse{RawResponse: resp.Response, WorkloadNetworkSegmentsList: val}, nil
}

// listSegmentsHandleError handles the ListSegments error response.
func (client *WorkloadNetworksClient) listSegmentsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListVMGroups - List of vm groups in a private cloud workload network.
func (client *WorkloadNetworksClient) ListVMGroups(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVMGroupsOptions) WorkloadNetworkVMGroupsListPager {
	return &workloadNetworkVMGroupsListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listVMGroupsCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listVMGroupsHandleResponse,
		errorer:   client.listVMGroupsHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkVMGroupsListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkVMGroupsList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listVMGroupsCreateRequest creates the ListVMGroups request.
func (client *WorkloadNetworksClient) listVMGroupsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVMGroupsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listVMGroupsHandleResponse handles the ListVMGroups response.
func (client *WorkloadNetworksClient) listVMGroupsHandleResponse(resp *azcore.Response) (WorkloadNetworkVMGroupsListResponse, error) {
	var val *WorkloadNetworkVMGroupsList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVMGroupsListResponse{}, err
	}
	return WorkloadNetworkVMGroupsListResponse{RawResponse: resp.Response, WorkloadNetworkVMGroupsList: val}, nil
}

// listVMGroupsHandleError handles the ListVMGroups error response.
func (client *WorkloadNetworksClient) listVMGroupsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListVirtualMachines - List of virtual machines in a private cloud workload network.
func (client *WorkloadNetworksClient) ListVirtualMachines(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVirtualMachinesOptions) WorkloadNetworkVirtualMachinesListPager {
	return &workloadNetworkVirtualMachinesListPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listVirtualMachinesCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		responder: client.listVirtualMachinesHandleResponse,
		errorer:   client.listVirtualMachinesHandleError,
		advancer: func(ctx context.Context, resp WorkloadNetworkVirtualMachinesListResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkVirtualMachinesList.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listVirtualMachinesCreateRequest creates the ListVirtualMachines request.
func (client *WorkloadNetworksClient) listVirtualMachinesCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVirtualMachinesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listVirtualMachinesHandleResponse handles the ListVirtualMachines response.
func (client *WorkloadNetworksClient) listVirtualMachinesHandleResponse(resp *azcore.Response) (WorkloadNetworkVirtualMachinesListResponse, error) {
	var val *WorkloadNetworkVirtualMachinesList
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVirtualMachinesListResponse{}, err
	}
	return WorkloadNetworkVirtualMachinesListResponse{RawResponse: resp.Response, WorkloadNetworkVirtualMachinesList: val}, nil
}

// listVirtualMachinesHandleError handles the ListVirtualMachines error response.
func (client *WorkloadNetworksClient) listVirtualMachinesHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginUpdateDhcp - Create or update dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginUpdateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (WorkloadNetworkDhcpPollerResponse, error) {
	resp, err := client.updateDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return WorkloadNetworkDhcpPollerResponse{}, err
	}
	result := WorkloadNetworkDhcpPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.UpdateDhcp", "", resp, client.updateDhcpHandleError)
	if err != nil {
		return WorkloadNetworkDhcpPollerResponse{}, err
	}
	poller := &workloadNetworkDhcpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkDhcpResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdateDhcp creates a new WorkloadNetworkDhcpPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkDhcpPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeUpdateDhcp(token string) (WorkloadNetworkDhcpPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateDhcp", token, client.updateDhcpHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkDhcpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// UpdateDhcp - Create or update dhcp by id in a private cloud workload network.
func (client *WorkloadNetworksClient) updateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (*azcore.Response, error) {
	req, err := client.updateDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updateDhcpHandleError(resp)
	}
	return resp, nil
}

// updateDhcpCreateRequest creates the UpdateDhcp request.
func (client *WorkloadNetworksClient) updateDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkDhcp)
}

// updateDhcpHandleResponse handles the UpdateDhcp response.
func (client *WorkloadNetworksClient) updateDhcpHandleResponse(resp *azcore.Response) (WorkloadNetworkDhcpResponse, error) {
	var val *WorkloadNetworkDhcp
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkDhcpResponse{}, err
	}
	return WorkloadNetworkDhcpResponse{RawResponse: resp.Response, WorkloadNetworkDhcp: val}, nil
}

// updateDhcpHandleError handles the UpdateDhcp error response.
func (client *WorkloadNetworksClient) updateDhcpHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginUpdatePortMirroring - Create or update a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginUpdatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (WorkloadNetworkPortMirroringPollerResponse, error) {
	resp, err := client.updatePortMirroring(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return WorkloadNetworkPortMirroringPollerResponse{}, err
	}
	result := WorkloadNetworkPortMirroringPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.UpdatePortMirroring", "", resp, client.updatePortMirroringHandleError)
	if err != nil {
		return WorkloadNetworkPortMirroringPollerResponse{}, err
	}
	poller := &workloadNetworkPortMirroringPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkPortMirroringResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdatePortMirroring creates a new WorkloadNetworkPortMirroringPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkPortMirroringPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeUpdatePortMirroring(token string) (WorkloadNetworkPortMirroringPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.UpdatePortMirroring", token, client.updatePortMirroringHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkPortMirroringPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// UpdatePortMirroring - Create or update a port mirroring profile by id in a private cloud workload network.
func (client *WorkloadNetworksClient) updatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (*azcore.Response, error) {
	req, err := client.updatePortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updatePortMirroringHandleError(resp)
	}
	return resp, nil
}

// updatePortMirroringCreateRequest creates the UpdatePortMirroring request.
func (client *WorkloadNetworksClient) updatePortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkPortMirroring)
}

// updatePortMirroringHandleResponse handles the UpdatePortMirroring response.
func (client *WorkloadNetworksClient) updatePortMirroringHandleResponse(resp *azcore.Response) (WorkloadNetworkPortMirroringResponse, error) {
	var val *WorkloadNetworkPortMirroring
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkPortMirroringResponse{}, err
	}
	return WorkloadNetworkPortMirroringResponse{RawResponse: resp.Response, WorkloadNetworkPortMirroring: val}, nil
}

// updatePortMirroringHandleError handles the UpdatePortMirroring error response.
func (client *WorkloadNetworksClient) updatePortMirroringHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginUpdateSegments - Create or update a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginUpdateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (WorkloadNetworkSegmentPollerResponse, error) {
	resp, err := client.updateSegments(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return WorkloadNetworkSegmentPollerResponse{}, err
	}
	result := WorkloadNetworkSegmentPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.UpdateSegments", "", resp, client.updateSegmentsHandleError)
	if err != nil {
		return WorkloadNetworkSegmentPollerResponse{}, err
	}
	poller := &workloadNetworkSegmentPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkSegmentResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdateSegments creates a new WorkloadNetworkSegmentPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkSegmentPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeUpdateSegments(token string) (WorkloadNetworkSegmentPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateSegments", token, client.updateSegmentsHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkSegmentPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// UpdateSegments - Create or update a segment by id in a private cloud workload network.
func (client *WorkloadNetworksClient) updateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (*azcore.Response, error) {
	req, err := client.updateSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updateSegmentsHandleError(resp)
	}
	return resp, nil
}

// updateSegmentsCreateRequest creates the UpdateSegments request.
func (client *WorkloadNetworksClient) updateSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkSegment)
}

// updateSegmentsHandleResponse handles the UpdateSegments response.
func (client *WorkloadNetworksClient) updateSegmentsHandleResponse(resp *azcore.Response) (WorkloadNetworkSegmentResponse, error) {
	var val *WorkloadNetworkSegment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkSegmentResponse{}, err
	}
	return WorkloadNetworkSegmentResponse{RawResponse: resp.Response, WorkloadNetworkSegment: val}, nil
}

// updateSegmentsHandleError handles the UpdateSegments error response.
func (client *WorkloadNetworksClient) updateSegmentsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BeginUpdateVMGroup - Create or update a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) BeginUpdateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (WorkloadNetworkVMGroupPollerResponse, error) {
	resp, err := client.updateVMGroup(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return WorkloadNetworkVMGroupPollerResponse{}, err
	}
	result := WorkloadNetworkVMGroupPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("WorkloadNetworksClient.UpdateVMGroup", "", resp, client.updateVMGroupHandleError)
	if err != nil {
		return WorkloadNetworkVMGroupPollerResponse{}, err
	}
	poller := &workloadNetworkVMGroupPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WorkloadNetworkVMGroupResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdateVMGroup creates a new WorkloadNetworkVMGroupPoller from the specified resume token.
// token - The value must come from a previous call to WorkloadNetworkVMGroupPoller.ResumeToken().
func (client *WorkloadNetworksClient) ResumeUpdateVMGroup(token string) (WorkloadNetworkVMGroupPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateVMGroup", token, client.updateVMGroupHandleError)
	if err != nil {
		return nil, err
	}
	return &workloadNetworkVMGroupPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// UpdateVMGroup - Create or update a vm group by id in a private cloud workload network.
func (client *WorkloadNetworksClient) updateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (*azcore.Response, error) {
	req, err := client.updateVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updateVMGroupHandleError(resp)
	}
	return resp, nil
}

// updateVMGroupCreateRequest creates the UpdateVMGroup request.
func (client *WorkloadNetworksClient) updateVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2020-07-17-preview")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(workloadNetworkVMGroup)
}

// updateVMGroupHandleResponse handles the UpdateVMGroup response.
func (client *WorkloadNetworksClient) updateVMGroupHandleResponse(resp *azcore.Response) (WorkloadNetworkVMGroupResponse, error) {
	var val *WorkloadNetworkVMGroup
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WorkloadNetworkVMGroupResponse{}, err
	}
	return WorkloadNetworkVMGroupResponse{RawResponse: resp.Response, WorkloadNetworkVMGroup: val}, nil
}

// updateVMGroupHandleError handles the UpdateVMGroup error response.
func (client *WorkloadNetworksClient) updateVMGroupHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
